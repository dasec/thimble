/*
 *  THIMBLE --- Research Library for Development and Analysis of
 *  Fingerprint Based Biometric Cryptosystems.
 *
 *  Copyright 2014 Benjamin Tams
 *
 *  THIMBLE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of
 *  the License, or (at your option) any later version.
 *
 *  THIMBLE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with THIMBLE. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file BCHCodeBase.h
 *
 * @brief
 *            Provides a class for generating binary BCH codes that can
 *            be used for bit error-correction.
 *
 * @author Benjamin Tams
 */

#ifndef THIMBLE_BCHCODEBASE_H
#define THIMBLE_BCHCODEBASE_H

#include <thimble/dllcompat.h>
#include <thimble/math/numbertheory/BinaryPolynomial.h>

#include <vector>

#ifdef THIMBLE_BUILD_DLL
template class THIMBLE_DLL std::allocator<thimble::BinaryPolynomial>;
template class THIMBLE_DLL std::vector<thimble::BinaryPolynomial,std::allocator<thimble::BinaryPolynomial> >;
#endif

/**
 * @brief The library's namespace
 */
namespace thimble {

    /**
     * @brief
     *             Instances of this class represent binary BCH codes
     *             enabling a bit error-correcting scheme for binary
     *             polynomials.
     *
     * @see <a href="http://en.wikipedia.org/wiki/BCH_code" target="_blank">http://en.wikipedia.org/wiki/BCH_code</a>
     */
    class THIMBLE_DLL BCHCodeBase {

    private:

        /**
         * @brief
         *            Block length of the BCH code.
         */
        int n;

        /**
         * @brief
         *            Dimension of the BCH code.
         */
        int k;

        /**
         * @brief
         *            Minimal distance of the BCH code.
         */
        int d;

        /**
         * @brief
         *            The generator polynomial of the BCH code.
         */
        BinaryPolynomial g;

        /**
         * @brief
         *            Irreducible minimal polynomial of a primitive
         *            <i>\link n\endlink</i>th root of unity in the
         *            binary field \f$GF(2)=\{0,1\}\f$.
         *
         * @details
         *            Note that the polynomial defines a
         *            field of size \f$2^n\f$, i.e.,
         *            \f[
         *   GF(2^n)\simeq GF(2)[X]/(f(X)\cdot GF(2)[X]).
         *            \f]
         */
        BinaryPolynomial f;

        /**
         * @brief
         *             Contains the polynomials \f$X^j~rem~f(X)\f$
         *             where <i>j=0,...,\link d\endlink</i>.
         *
         * @details
         *             If \f$\beta\f$ is an <i>\link n\endlink</i>th
         *             root of unity, then the vector contains the
         *             polynomial representants of the powers
         *             \f$\beta^j\f$ at the index <i>j</i> where
         *             <i>j=0,...,\link d\endlink</i>.
         */
        std::vector<BinaryPolynomial> powers_of_X_mod_f;

        /**
         * @brief
         *             Determines the non-zero roots of a polynomial
         *             with coefficients in the field \f$GF(2^n)\f$ defined
         *             by the member <i>\link f\endlink</i>.
         *
         * @details
         *             The functions requires a polynomial
         *             \f[
         * \Lambda(X)=\lambda_0+\lambda_1\cdot X+\lambda_2\cdot X^2+...
         *    +\lambda_t\cdot X^t
         *             \f]
         *             such that \f$\lambda_j\in GF(2^n)\f$ (where
         *             \f$GF(2^n)\f$ is given by polynomial arithmetic modulo
         *             <i>\link f\endlink</i>) and determines its non-zero
         *             roots as follows:
         *             Let \f$\beta=(X~mod~f(X))\in GF(2^n)\f$; then the group
         *             of unity \f$GF(2^n)^\times=\langle\beta\rangle\f$ is
         *             generated by \f$\beta\f$ since a primite
         *             <i>\link n\endlink</i>th root of unity. If
         *             \f$\alpha_1,...,\alpha_\ell\f$ are the roots of
         *             \f$\Lambda(X)\f$, there exists non-negative integers
         *             \f$i_1,...,i_\ell\f$ such that
         *             \f$\alpha_j=\beta^{i_j}\f$. The function returns a vector
         *             containing the distinct exponents \f$i_j\f$
         *             (\f$j=1,...,\ell\f$).
         *
         *             The implementation of the function follows the
         *             <i>
         *              <a href="http://en.wikipedia.org/wiki/Chien_search"
         *               target="_blank">
         *               Chien search
         *              </a>
         *             </i>
         *             approach.
         *
         * @param Lambda
         *             An array of length <i>t+1</i>
         *             (where <i>t</i>\f$\leq\f$<i>\link d\endlink</i>)
         *             such that the entry <code>Lambda[j]</code>
         *             (modulo <i>\link f\endlink</i>) defines
         *             the <i>j</i>th coefficient \f$\lambda_j\f$ of the
         *             polynomial \f$\Lambda(X)\f$.
         *
         * @return
         *             A list of the distinct exponents \f$i_j\f$ of the
         *             non-zero roots \f$\alpha_j=\beta^{i_j}\f$ of the
         *             polynomial \f$\Lambda(X)\f$.
         *
         * @see <ul>
         *       <li>
         *        <b>Chien (1964)</b>.
         *        Cyclic Decoding Procedures for the Bose-Chaudhuri-Hocquenghem
         *        Codes.
         *        <i>IEEE Trans. Information Theory</i>, IT-10 (4): 357--363.
         *       </li>
         *      </ul>
         *
         * @warning
         *             If the requirement on the input <code>Lambda</code>
         *             is violated, a call of this function runs into
         *             undocumented behaviour.
         *
         * @warning
         *             If not enough memory could be provided, an error
         *             message is printed to <code>stderr</code> and the
         *             program exits with status 'EXIT_FAILURE'.
         */
        std::vector<int> chienSearch
        ( const std::vector<BinaryPolynomial> & Lambda ) const;

    public:

        /**
         * @brief
         *            Creates a binary BCH code of given length that can
         *            tolerate at least the specified number of bit errors.
         *
         * @details
         *            The constructor takes a positive odd number <i>n</i>
         *            defining the block length of the code and a lower
         *            bound on the designed error tolerance. From the input
         *            a BCH code of block length <i>n</i> is generated that
         *            can tolerate at least the specified number of errors
         *            in a transmitted binary codeword being represented
         *            by \link BinaryPolynomial binary polynomials\endlink
         *            of degree smaller than <i>n</i>.
         *
         *            Parts of the BCH code generation have been implemented
         *            following the description of
         *            <ul>
         *             <li><b>[vzGth]</b> v.z. Gathen and Gerhard (2003).
         *              <i>Modern Computer Algebra</i>. Cambridge University
         *              Press, Cambridge (UK), 2nd edition.
         *             </li>
         *            </ul>
         *
         * @param n
         *            The block length of the BCH code.
         *
         * @param errorTolerance
         *            A lower bound on the number of errors that the
         *            code should be able to correct.
         *
         * @warning
         *            If <i>n</i> is negative or even or if the relation
         *            \f$1\leq 2\cdot errorTolerance+1\leq n\f$ is not
         *            fulfilled, an error message is printed to
         *            <code>stderr</code> and the program exits with status
         *            'EXIT_FAILURE'.
         *
         * @warning
         *            If not enough memory could be provided, an error
         *            message is printed to <code>stderr</code> and the
         *            program exits with status 'EXIT_FAILURE'.
         */
        BCHCodeBase( int n , int errorTolerance );

        /**
         * @brief
         *            Copy constructor.
         *
         * @param code
         *            The BCH code of which a copy is created.
         *
         * @warning
         *            If not enough memory could be provided, an error
         *            message is printed to <code>stderr</code> and the
         *            program exits with status 'EXIT_FAILURE'.
         */
        BCHCodeBase( const BCHCodeBase & code );

        /**
         * @brief
         *            Destructor.
         *
         * @details
         *            Ensures that all data helt by this instance is
         *            freed.
         */
        ~BCHCodeBase();

        /**
         * @brief
         *            Assignment operator.
         *
         * @details
         *            The data of this BCH code is overwritten by the
         *            data in <code>code</code>.
         *
         * @param code
         *            The BCH code assigned to this instance.
         *
         * @return
         *            A reference to this BCH code (after assignment).
         *
         * @warning
         *            If not enough memory could be provided, an error
         *            message is printed to <code>stderr</code> and the
         *            program exits with status 'EXIT_FAILURE'.
         */
        BCHCodeBase &operator=( const BCHCodeBase & code );

        /**
         * @brief
         *            Attempts to round the input bit sequence to its
         *            nearest codeword.
         *
         * @details
         *            If the BCH code contains a word <i>w</i> that differs
         *            in no more than \link getErrorTolerance()\endlink bits
         *            from  <i>c</i>, then the content of <i>c</i>
         *            is replaced by <i>w</i> and the function returns
         *            <code>true</code>. Otherwise, the function is expected
         *            to return <code>false</code> and leaves <i>c</i>
         *            unchanged.
         *
         * @param c
         *            On input and output a polynomial of degree smaller than
         *            \link getBlockLength()\endlink.
         *
         * @return
         *            <code>true</code> if <i>c</i> was successfully
         *            rounded to a codeword; otherwise, <code>false</code>.
         *
         * @warning
         *            If <i>c</i> is of degree larger than or equals
         *            \link getBlockLength()\endlink an error message is
         *            printed to <code>stderr</code> and the program exits
         *            with status 'EXIT_FAILURE'.
         *
         * @warning
         *            If not enough memory could be provided, an error
         *            message is printed to <code>stderr</code> and the
         *            program exits with status 'EXIT_FAILURE'.
         */
        bool round( BinaryPolynomial & c ) const;

        /**
         * @brief
         *            Attaches checkbits to a message polynomial such
         *            that it becomes its encoding code polynomial.
         *
         * @details
         *            The encoding procedure implemented is systematic in the
         *            sense that the upper
         *            <i>k=</i>\link getDimension()\endlink coefficients of
         *            the code polynomial form the coefficients of the input
         *            message polynomial.
         *
         * @param c
         *            On input, the message polynomial of degree at most
         *            <i>k=</i>\link getDimension()\endlink; on output, a
         *            polynomial of degree smaller than
         *            <i>n=</i>\link getBlockLength()\endlink such that its
         *            upper <i>k</i> coefficients form the input message
         *            polynomial.
         *
         * @warning
         *            If the degree of the input message polynomial is larger
         *            than or equals <i>k=</i>\link getDimension()\endlink,
         *            an error message is printed to <code>stderr</code> and
         *            the program exits with status 'EXIT_FAILURE'.
         *
         * @warning
         *            If not enough memory could be provided, an error
         *            message is printed to <code>stderr</code> and the
         *            program exits with status 'EXIT_FAILURE'.
         */
        void encode( BinaryPolynomial & c ) const;

        /**
         * @brief
         *            Rounds the input polynomial to its nearest codeword
         *            and, if successful, removes the checkbits thereby
         *            obtaining the code polynomial's message polynomial.
         *
         * @details
         *            Apart from error-correction, this method performs the
         *            inverse of the \link encode()\endlink method.
         *
         * @param m
         *            On input, a polynomial of degree at most
         *            <i>n=</i>\link getBlockLength()\endlink. On successful
         *            decoding, a message polynomial of degree at most
         *            <i>k=</i>\link getDimension()\endlink; otherwise, if
         *            decoding failed, the content of <i>m</i> is left
         *            unchanged.
         *
         * @return
         *            <code>true</code> if decoding was successful; otherwise,
         *            if the decoding attempt failed, the function returns
         *            <code>false</code>.
         *
         * @warning
         *            If <i>m</i> is of degree larger than or equals
         *            <i>n=</i>\link getBlockLength()\endlink, an error
         *            message is printed to <code>stderr</code> and the
         *            program exits with status 'EXIT_FAILURE'.
         *
         * @warning
         *            If not enough memory could be provided, an error
         *            message is printed to <code>stderr</code> and the
         *            program exits with status 'EXIT_FAILURE'.
         */
        bool decode( BinaryPolynomial & m ) const;

        /**
         * @brief
         *           Creates a random code polynomial.
         *
         * @param c
         *           On output, a random code polynomial.
         *
         * @param tryRandom
         *           If <code>true</code>, the method uses a cryptographic
         *           number generator if available on the system; otherwise,
         *           the method wraps around the standard <code>rand()</code>
         *           function.
         *
         * @warning
         *           If not enough memory could be provided, an error
         *           message is printed to <code>stderr</code> and the
         *           program exits with status 'EXIT_FAILURE'.
         */
        void random( BinaryPolynomial & c , bool tryRandom = false ) const;


        /**
         * @brief
         *          Returns the block length \f$n\f$ of the BCH code.
         *
         * @return
         *          The block length of the BCH code.
         */
        inline int getBlockLength() const {
            return this->n;
        }

        /**
         * @brief
         *          Returns the dimension \f$k\f$ of the code as a linear
         *          sub-space of \f$\{0,1\}^n\f$.
         *
         * @return
         *          The dimension of the code.
         */
        inline int getDimension() const {
            return this->k;
        }

        /**
         * @brief
         *          Returns the minimal distance of the code.
         *
         * @return
         *          The minimal distance of the code.
         */
        inline int getMinimalDistance() const {
            return this->d;
        }

        /**
         * @brief
         *          Returns the number of bit errors that this code is able
         *          to correct.
         *
         * @return
         *          The number of bit errors that can be corrected by this
         *          code.
         */
        inline int getErrorTolerance() const {
            return (this->d-1)/2;
        }

        /**
         * @brief
         *          Returns the generator polynomial for this cyclic BCH
         *          code.
         *
         * @return
         *          The generator polynomial of degree equals
         *        \link getBlockLength()\endlink-\link getDimension()\endlink.
         */
        inline const BinaryPolynomial & getGeneratorPolynomial() const {
            return this->g;
        }

        /**
         * @brief
         *          Returns an irreducible polynomial being the minimal
         *          polynomial of a primitive <i>n</i>th root of unity.
         *
         * @details
         *          By definition, BCH codes are generated by the minimal
         *          polynomial of \f$\beta^1,\beta^2,...,\beta^{\delta-1}\f$
         *          where \f$\beta\f$ is a primitive <i>n</i>th root of unity
         *          (<i>n=</i>getBlockLength() and \f$\delta\f$ is the
         *          code's planned minimal distance). The minimal polynomial
         *          of \f$\beta\f$ (which is an irreducible polynomial of
         *          degree <i>n</i>) defines a finite field of cardinality
         *          \f$2^n\f$ whose properties can be exploited on
         *          error-correction. This polynomial is accessed by this
         *          function.
         *
         * @return
         *          An irreducible polynomial being the minimal polynomial
         *          of a primitive <i>n</i>th root of unity.
         */
        inline const BinaryPolynomial & getModulus() const {
            return this->f;
        }

        /**
         * @brief
         *            Implementation of the Berlekamp-Massey algorithm
         *            for finding the minimal polynomial of a linearly
         *            recurrent sequence in a finite field.
         *
         * @details
         *            If for a sequence \f$(S_j)_{j\geq 0}\f$ in a finite
         *            field \f$F\f$ there exist a non-zero polynomial
         * \f$\Lambda(X)=\lambda_0+\lambda_1\cdot X+...+\lambda_n\cdot X^t\f$
         *            such that
         *            \f[
         *             \sum_{0\leq j\leq t}\lambda_j\cdot S_j=0,
         *            \f]
         *            then \f$\Lambda(X)\f$ is called
         *            <em>characteristic polynomial</em> of <i>S</i>. If, in
         *            addition, the degree of \f$\Lambda(X)\f$ is minimal,
         *            then \f$\Lambda(X)\f$ is called
         *            <em>minimal polynomial</em> of <i>S</i>.
         *
         *            Given the first \f$2t\f$ coefficients of a (linearly
         *            recurrent) sequence in the finite field defined by
         *            <i>f</i>, this function computes its minimal polynomial
         *            \f$\Lambda(X)\f$ by returning a vector
         * <pre>
         *  vector<BinaryPolynomial> Lambda;
         * </pre>
         *            of length at most <i>t+1</i> where the coefficients
         *            \f$\lambda_j\f$ are represented by the
         *            <code>Lambda[j]</code> (modulo <i>f</i>).
         *
         *            This function is used in the \link round()\endlink
         *            function to find the error-locator polynomial on
         *            decoding a BCH code.
         *
         * @param S
         *            Linearly recurrent sequence (modulo <i>f</i>) in the
         *            finite field whose defining polynomial is specified
         *            via the parameter <i>f</i>.
         *
         * @param f
         *            Should be an irreducible polynomial of degree
         *            greater than 1.
         *
         * @return
         *            A vector defining the minimal polynomial of the
         *            linearly recurrent sequence given by <i>S</i> modulo
         *            <i>f</i>.
         *
         * @warning
         *            If <i>f</i> is not an irreducible polynomial of degree
         *            at least 1, the behaviour of the function is
         *            undocumented.
         *
         * @warning
         *            If not enough memory could be provided, an error
         *            message is printed to <code>stderr</code> and the
         *            program exits with status 'EXIT_FAILURE'.
         */
        static std::vector<BinaryPolynomial> berlekampMassey
        ( const std::vector<BinaryPolynomial> & S ,
          const BinaryPolynomial & f );
    };
}

#endif /* THIMBLE_BCHCODEBASE_H */
